\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}

%%% Packages
% Math
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\numberwithin{equation}{section}
\theoremstyle{plain}
\newtheorem{claim}{Claim}
\newtheorem{corollary}{Corollary}
\newtheorem{booktheoremX}{(Textbook) Theorem}
\newenvironment{booktheorem}[1]{%
\renewcommand\thebooktheoremX{#1}%
\booktheoremX
}{\endbooktheoremX}

% Pseudo code
\usepackage{algorithm, algpseudocode}

% I think this needs to be the last package
\usepackage{hyperref}
%%%

%%% Commands
%% General
\newcommand{\set}[1]{\{ #1 \}}
\mathchardef\mhyphen="2D 

%% Probability commands
\DeclareMathOperator*{\prob}{Pr}
\newcommand{\given}{\mid}

%% Crypto commands
\newcommand{\ppt}{\algo{PPT}}
\newcommand{\func}{\algo{Func}}
\newcommand{\ctexts}{\mathcal{C}}
\newcommand{\ctext}{\algo{C}}
\newcommand{\ptexts}{\mathcal{M}}
\newcommand{\ptext}{\algo{M}}
\newcommand{\keys}{\mathcal{K}}
\newcommand{\key}{\algo{K}}
\newcommand{\algo}[1]{\mathsf{#1}}
\newcommand{\adv}{\mathcal{A}}
\newcommand{\advv}{\mathcal{A}'}
\DeclareMathOperator{\negl}{\algo{negl}}
% Private key
\newcommand{\priv}{\Pi}
\newcommand{\gen}{\algo{Gen}}
\newcommand{\enc}{\algo{Enc}}
\newcommand{\dec}{\algo{Dec}}
\newcommand{\mac}{\algo{Mac}}
\newcommand{\param}{1}
\newcommand{\privexpir}[3]{\algo{PrivK}^{#1}_{{#2},{#3}}}
\newcommand{\macexpir}[2]{\algo{MACForge}_{{#1},{#2}}}
\newcommand{\eav}{\algo{eav}}
\newcommand{\cpa}{\algo{cpa}}
%%%

\title{%
CSE 5351 Spring 2020\\
Homework 5
}
\author{%
Caleb Lehman
(\href{mailto:lehman.346@osu.edu}{\texttt{lehman.346@osu.edu}})
}
\date{%
}

\begin{document}

\maketitle

\section*{Problem 1}

\begin{claim}
Modify basic $\algo{CBC}\mhyphen \algo{MAC}$ as follows:
For key $k \in \set{ 0, 1 }^n$ and message $m \in \set{ 0, 1 }^{nq}$,
\begin{itemize}
    \item parse $m$ as $m = (m_1, \ldots, m_q)$
    \item let $t_0 \gets_u \set{ 0, 1 }^n$,
    $t_i = F_k(m_i \oplus t_{i-1})$ for $1 \leq i \leq q$
    \item output $\langle t_0, t_q \rangle$ as the tag
\end{itemize}
Then this modified fixed-length $\mac$ scheme is \textbf{not} secure.
\end{claim}
\begin{proof}
Call the modified encryption scheme $\Pi$
and suppose we only have access to an oracle $\mac_k(\cdot)$.
We can get the valid pair $(m_0, \langle t_0, t \rangle) = \mac_k(m_0)$ for the message $m_0 = 0^n$,
where $t = F_k(m_0 \oplus t_0) = F_k(t_0)$ by the definition of $\algo{CBC}$ mode.
Then for any $m \in \set{ 0, 1 }^n$, we have
$F_k((t_0 \oplus m) \oplus m) = F_k(t_0) = t$,
so the pair $(m, \langle t_0 \oplus m, t \rangle)$ is valid.
By choosing $m \neq 0^n$, this process easily defines an adversary, $\adv$,
that always wins experiment $\macexpir{\adv}{\Pi}(\cdot)$.
It follows that $\Pi$ is not secure.
\end{proof}

\section*{Problem 2}

\textbf{TO-DO}

\section*{Problem 3}

\begin{claim}
Let $F$ be a pseudorandom function
and construct a fixed-length $\mac$ scheme for messages as follows:
For key $k \in \set{ 0, 1 }^n$ and message $m \in \set{ 0, 1 }^{2n}$,
\begin{itemize}
    \item parse $m$ as $m = m_1 \| m_2$, where $|m_1| = |m_2| = n$
    \item output $F_k(m_1) \| F_k(F_k(m_2))$ as the tag
\end{itemize}
Then this fixed-length $\mac$ scheme is \textbf{not} secure against chosen-message attacks.
\end{claim}
\begin{proof}
Note that the first half of the tag depends only on the first half of
the message and the second half of the tag depends only on the second
half of the message.
In particular, by querying the $\mac$ oracle on the messages
$m = m_1 \| m_2$ and $n = n_1 \| n_2$,
we get the tags
$t^m = t^m_1 \| t^m_2 = F_k(m_1) \| F_k(F_k(m_2))$ and $t^n = t^n_1 \| t^n_2 = F_k(n_1) \| F_k(F_k(n_2))$
which we can mix to make the valid pair
$\langle m_1 \| n_2, t^m_1 \| t^n_2 \rangle$.
This observation allows us to develop the following adversary:
\begin{algorithm}[H]
\begin{algorithmic}
\Procedure{Adversary}{}
    \State Send $m_0 = 0^n \| 0^n$ to the $\mac$ oracle
    \State Receive tag and set $t_0 \gets$ the \textit{first} half of the bits of the tag
    \State Send $m_1 = 1^n \| 1^n$ to the $\mac$ oracle
    \State Receive tag and set $t_1 \gets$ the \textit{second} half of the bits of the tag
    \State \Return $(0^n \| 1^n, t_0 \| t_1)$
\EndProcedure
\end{algorithmic}
\end{algorithm}
This adversary always wins the experiment $\macexpir{\adv}{\Pi}(\cdot)$,
so this scheme is not secure.
\end{proof}

\end{document}
